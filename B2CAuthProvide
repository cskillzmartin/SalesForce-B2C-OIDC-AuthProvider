public with sharing class B2CAuthProvider extends Auth.AuthProviderPluginClass {

    /* --------------------------------------------------------------------- */
    /*  Required override – tie plug-in to its configuration metadata       */
    /* --------------------------------------------------------------------- */
    public String getCustomMetadataType() {
        return 'B2CAuthProviderConfig__mdt';
    }

    /* --------------------------------------------------------------------- */
    /*  Cached configuration helper                                          */
    /* --------------------------------------------------------------------- */
    private B2CAuthProviderConfig__mdt cfg {
        get {
            if (cfg == null) {
                // One-record convention keeps the plug-in stateless.
                List<B2CAuthProviderConfig__mdt> configs = [SELECT clientid__c, clientSecret__c, tenant__c,
                               policy__c, redirectUri__c
                          FROM B2CAuthProviderConfig__mdt
                          WHERE DeveloperName = 'Init'
                          LIMIT 1];
                          
                if (configs.isEmpty()) {
                    throw new Auth.AuthProviderPluginException(
                        'B2C Auth Provider configuration not found. Please create a B2CAuthProviderConfig__mdt record with DeveloperName = "Default"'
                    );
                }
                
                cfg = configs[0];
                
                // Validate required fields
                if (String.isBlank(cfg.ClientId__c)) {
                    throw new Auth.AuthProviderPluginException('B2C Auth Provider: ClientId is required');
                }
                if (String.isBlank(cfg.Tenant__c)) {
                    throw new Auth.AuthProviderPluginException('B2C Auth Provider: Tenant is required');
                }
                if (String.isBlank(cfg.Policy__c)) {
                    throw new Auth.AuthProviderPluginException('B2C Auth Provider: Policy is required');
                }
                if (String.isBlank(cfg.RedirectUri__c)) {
                    throw new Auth.AuthProviderPluginException('B2C Auth Provider: RedirectUri is required');
                }
            }
            return cfg;
        }
        private set;
    }

    /* --------------------------------------------------------------------- */
    /*  Step 1 – Build the B2C authorize URL and hand control to Microsoft   */
    /* --------------------------------------------------------------------- */
    public PageReference initiate(Map<String,String> pluginConfig,
                                           String state) {
        try {
            String authBase = 'https://' + cfg.Tenant__c +
                              '.b2clogin.com/' + cfg.Tenant__c +
                              '.onmicrosoft.com/' + cfg.Policy__c +
                              '/oauth2/v2.0/authorize';

            String url = authBase + '?client_id='      + EncodingUtil.urlEncode(cfg.ClientId__c, 'UTF-8') +
                                   '&response_type=id_token' +
                                   '&redirect_uri='    + EncodingUtil.urlEncode(cfg.RedirectUri__c, 'UTF-8') +
                                   '&scope=openid%20offline_access' +
                                   '&response_mode=form_post' +
                                   '&nonce='           + String.valueOf(Crypto.getRandomLong()) +
                                   '&state='           + EncodingUtil.urlEncode(state, 'UTF-8');
            
            System.debug('B2C Auth URL: ' + url);
            return new PageReference(url);
        } catch (Exception e) {
            throw new Auth.AuthProviderPluginException('Failed to initiate B2C authentication: ' + e.getMessage());
        }
    }

    /* --------------------------------------------------------------------- */
    /*  Step 2 – Handle form_post callback.  Parse and validate the JWT.     */
    /* --------------------------------------------------------------------- */
    public Auth.AuthProviderTokenResponse handleCallback(
            Map<String,String> pluginConfig,
            Auth.AuthProviderCallbackState callbackState) {

        try {
            String idToken = callbackState.queryParameters.get('id_token');
            if (String.isBlank(idToken)) {
                String error = callbackState.queryParameters.get('error');
                String errorDescription = callbackState.queryParameters.get('error_description');
                String errorMessage = 'AAD B2C did not return id_token';
                if (String.isNotBlank(error)) {
                    errorMessage += '. Error: ' + error;
                    if (String.isNotBlank(errorDescription)) {
                        errorMessage += '. Description: ' + errorDescription;
                    }
                }
                throw new Auth.AuthProviderPluginException(errorMessage);
            }

            // Validate JWT structure and basic claims
            validateJwtStructure(idToken);

            // Build token response for downstream methods.
            Auth.AuthProviderTokenResponse resp = new Auth.AuthProviderTokenResponse(
                'B2C',                     // provider name
                null,                      // access token (not used in ID token flow)
                null,                      // refresh token
                callbackState.queryParameters.get('state') // state
            );
            resp.idToken     = idToken;
            return resp;
        } catch (Exception e) {
            throw new Auth.AuthProviderPluginException('Failed to handle B2C callback: ' + e.getMessage());
        }
    }

    /* --------------------------------------------------------------------- */
    /*  Step 3 – Map JWT claims to Salesforce user attributes.               */
    /* --------------------------------------------------------------------- */
    public Auth.UserData getUserInfo(Map<String,String> pluginConfig,
                                              Auth.AuthProviderTokenResponse resp) {
        try {
            Map<String,Object> claims = decodeJwt(resp.idToken);

            // Handle different email claim formats
            String primaryEmail = extractEmail(claims);
            String identifier = (String)claims.get('oid');
            String firstName = (String)claims.get('given_name');
            String lastName = (String)claims.get('family_name');
            String fullName = buildFullName(firstName, lastName);
            String username = String.isNotBlank(primaryEmail) ? primaryEmail : identifier;
            
            // Validate required fields
            if (String.isBlank(identifier)) {
                throw new Auth.AuthProviderPluginException('B2C token missing required "oid" claim');
            }
            
            Auth.UserData u = new Auth.UserData(
                identifier,                  // identifier - maps to User.FederationIdentifier
                firstName,                   // firstName
                lastName,                    // lastName  
                fullName,                    // fullName
                primaryEmail,                // email
                null,                        // link - not used
                username,                    // username
                null,                        // locale - could be extracted from claims if needed
                'B2C',                       // provider
                null,                        // siteLoginUrl - not used
                new Map<String,String>()     // attributeMap - must be Map<String,String>
            );
            
            return u;
        } catch (Exception e) {
            throw new Auth.AuthProviderPluginException('Failed to extract user info from B2C token: ' + e.getMessage());
        }
    }

    /* --------------------------------------------------------------------- */
    /*  Token refresh not applicable – return null so the platform stops.    */
    /* --------------------------------------------------------------------- */
    public override Auth.OAuthRefreshResult refresh(Map<String,String> pluginConfig,
                                                    String refreshToken) {
        return null; // B2C doesn't issue renewable refresh tokens in this flow
    }

    /* --------------------------------------------------------------------- */
    /*  Utility – Validate JWT structure and basic security properties       */
    /* --------------------------------------------------------------------- */
    private static void validateJwtStructure(String jwt) {
        if (String.isBlank(jwt)) {
            throw new Auth.AuthProviderPluginException('JWT token is blank');
        }
        
        List<String> parts = jwt.split('\\.');
        if (parts.size() != 3) {
            throw new Auth.AuthProviderPluginException('Invalid JWT structure - expected 3 parts');
        }
        
        // Validate token hasn't expired
        Map<String,Object> claims = decodeJwt(jwt);
        if (claims.containsKey('exp')) {
            Long exp = extractLongClaim(claims, 'exp');
            Long nowSec = DateTime.now().getTime() / 1000;
            if (exp < nowSec) {
                throw new Auth.AuthProviderPluginException('JWT token has expired');
            }
        }
        
        // Validate issuer if present
        if (claims.containsKey('iss')) {
            String issuer = (String)claims.get('iss');
            if (String.isNotBlank(issuer) && !issuer.contains('b2clogin.com')) {
                throw new Auth.AuthProviderPluginException('JWT issuer is not a valid B2C issuer: ' + issuer);
            }
        }
    }

    /* --------------------------------------------------------------------- */
    /*  Utility – Decode base64url JWT payload into a Map.                    */
    /* --------------------------------------------------------------------- */
    private static Map<String,Object> decodeJwt(String jwt) {
        List<String> parts = jwt.split('\\.');
        if (parts.size() < 2) {
            throw new Auth.AuthProviderPluginException('Invalid JWT');
        }
        String payload = parts[1];
        payload = payload.replace('-', '+').replace('_', '/');
        while ( (payload.length() - (4 * (payload.length() / 4))) != 0 ) {
            payload += '=';
        }
        try {
            Blob jsonBlob = EncodingUtil.base64Decode(payload);
            return (Map<String,Object>)JSON.deserializeUntyped(jsonBlob.toString());
        } catch (Exception e) {
            throw new Auth.AuthProviderPluginException('Failed to decode JWT payload: ' + e.getMessage());
        }
    }

    /* --------------------------------------------------------------------- */
    /*  Utility – Extract email from various possible claim formats          */
    /* --------------------------------------------------------------------- */
    private static String extractEmail(Map<String,Object> claims) {
        // Try different email claim formats used by B2C
        if (claims.containsKey('emails')) {
            List<Object> emails = (List<Object>)claims.get('emails');
            if (emails != null && !emails.isEmpty()) {
                return (String)emails[0];
            }
        }
        
        if (claims.containsKey('email')) {
            return (String)claims.get('email');
        }
        
        if (claims.containsKey('signInNames.emailAddress')) {
            return (String)claims.get('signInNames.emailAddress');
        }
        
        return null;
    }

    /* --------------------------------------------------------------------- */
    /*  Utility – Build full name safely                                     */
    /* --------------------------------------------------------------------- */
    private static String buildFullName(String firstName, String lastName) {
        if (String.isNotBlank(firstName) && String.isNotBlank(lastName)) {
            return firstName + ' ' + lastName;
        } else if (String.isNotBlank(firstName)) {
            return firstName;
        } else if (String.isNotBlank(lastName)) {
            return lastName;
        }
        return '';
    }

    /* --------------------------------------------------------------------- */
    /*  Utility – Extract Long claim safely                                  */
    /* --------------------------------------------------------------------- */
    private static Long extractLongClaim(Map<String,Object> claims, String claimName) {
        Object claimValue = claims.get(claimName);
        if (claimValue instanceof Decimal) {
            return ((Decimal)claimValue).longValue();
        } else if (claimValue instanceof Long) {
            return (Long)claimValue;
        } else if (claimValue instanceof Integer) {
            return ((Integer)claimValue).longValue();
        }
        return 0L;
    }

    /* --------------------------------------------------------------------- */
    /*  Utility – Convert exp claim to relative TTL in seconds.               */
    /* --------------------------------------------------------------------- */
    private static Integer extractExpiry(String jwt) {
        Map<String,Object> claims = decodeJwt(jwt);
        if (!claims.containsKey('exp')) return 0;
        Long exp = extractLongClaim(claims, 'exp');
        Long nowSec = DateTime.now().getTime() / 1000;
        return (Integer)Math.max(0, exp - nowSec);
    }
}
